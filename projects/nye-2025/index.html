<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ğŸ† New Year 2025 - Fireworks Spectacular</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
    
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: Georgia, serif;
    }
    
    .title {
      font-size: clamp(60px, 18vw, 200px);
      font-weight: bold;
      background: linear-gradient(180deg, #fff 0%, #ffd700 50%, #ff6b00 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      filter: drop-shadow(0 0 30px rgba(255, 150, 0, 0.6)) drop-shadow(0 0 60px rgba(255, 100, 0, 0.4));
      animation: glow 2s ease-in-out infinite alternate, float 4s ease-in-out infinite;
      letter-spacing: 0.05em;
    }
    
    .subtitle {
      font-size: clamp(16px, 4vw, 36px);
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 0.5em;
      margin-top: 10px;
      text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 40px rgba(100, 200, 255, 0.6);
      animation: fadeIn 2s ease-out 0.5s both;
    }
    
    .message {
      position: absolute;
      bottom: 12%;
      font-size: clamp(20px, 5vw, 50px);
      font-weight: bold;
      background: linear-gradient(90deg, #ff0080, #ff8c00, #ffef00, #00ff88, #00cfff, #a855f7, #ff0080);
      background-size: 300% 100%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: rainbow 3s linear infinite;
      filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.4));
    }
    
    /* Screen flash effect */
    .flash-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 50;
      background: white;
      opacity: 0;
    }
    
    /* Controls hint */
    .controls-hint {
      position: fixed;
      bottom: 20px;
      right: 20px;
      font-family: system-ui, sans-serif;
      font-size: 12px;
      color: rgba(255,255,255,0.5);
      text-align: right;
      pointer-events: none;
      z-index: 200;
      animation: fadeIn 3s ease-out 2s both;
    }
    
    .controls-hint kbd {
      background: rgba(255,255,255,0.15);
      padding: 2px 6px;
      border-radius: 3px;
      margin: 0 2px;
    }
    
    /* Finale announcement */
    .finale-text {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(40px, 12vw, 120px);
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 40px #ff0080, 0 0 80px #ff8c00, 0 0 120px #ffef00;
      opacity: 0;
      pointer-events: none;
      z-index: 300;
      font-family: Georgia, serif;
    }
    
    .finale-text.show {
      animation: finaleText 3s ease-out forwards;
    }
    
    @keyframes finaleText {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
      40% { transform: translate(-50%, -50%) scale(1); }
      80% { opacity: 1; }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
    }
    
    @keyframes glow {
      from { filter: drop-shadow(0 0 30px rgba(255, 150, 0, 0.6)) drop-shadow(0 0 60px rgba(255, 100, 0, 0.4)); }
      to { filter: drop-shadow(0 0 50px rgba(255, 200, 0, 0.9)) drop-shadow(0 0 100px rgba(255, 150, 0, 0.6)); }
    }
    
    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    
    @keyframes rainbow {
      0% { background-position: 0% 50%; }
      100% { background-position: 300% 50%; }
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* Screen shake */
    .shake {
      animation: shake 0.3s ease-out;
    }
    
    @keyframes shake {
      0%, 100% { transform: translate(0, 0); }
      20% { transform: translate(-3px, 2px); }
      40% { transform: translate(3px, -2px); }
      60% { transform: translate(-2px, 3px); }
      80% { transform: translate(2px, -3px); }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="flash-overlay" id="flashOverlay"></div>
  
  <div class="overlay" id="mainOverlay">
    <div class="title">2025</div>
    <div class="subtitle">Happy New Year</div>
    <div class="message">âœ¨ Cheers to New Beginnings âœ¨</div>
  </div>
  
  <div class="finale-text" id="finaleText">ğŸ† GRAND FINALE ğŸ†</div>
  
  <div class="controls-hint">
    <kbd>F</kbd> Grand Finale Â· <kbd>S</kbd> Sound Â· <kbd>Click</kbd> Launch
  </div>

  <script>
  (function() {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CANVAS SETUP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const flashOverlay = document.getElementById('flashOverlay');
    const mainOverlay = document.getElementById('mainOverlay');
    const finaleText = document.getElementById('finaleText');
    
    let W, H;
    let skyGradientCache = null;
    
    // Performance limits
    const MAX_PARTICLES = 1000; // Increased for finale
    const MAX_ROCKETS = 20;
    const MAX_CONFETTI = 120;
    const TRAIL_LENGTH = 5;
    
    // State
    let soundEnabled = false;
    let finaleMode = false;
    let finaleEndTime = 0;
    
    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
      skyGradientCache = null;
    }
    
    window.addEventListener('resize', resize);
    resize();
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WEB AUDIO - SOUND EFFECTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let audioCtx = null;
    
    function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    function playLaunch() {
      if (!soundEnabled || !audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.setValueAtTime(400, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.3);
      gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.3);
    }
    
    function playBoom(big) {
      if (!soundEnabled || !audioCtx) return;
      const bufferSize = audioCtx.sampleRate * 0.4;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.15));
      }
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = big ? 400 : 600;
      const gain = audioCtx.createGain();
      gain.gain.value = big ? 0.4 : 0.25;
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      noise.start();
    }
    
    function playCrackle() {
      if (!soundEnabled || !audioCtx) return;
      const bufferSize = audioCtx.sampleRate * 0.08;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.3));
      }
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 2000;
      const gain = audioCtx.createGain();
      gain.gain.value = 0.1;
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      noise.start();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VISUAL EFFECTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function screenFlash(intensity) {
      flashOverlay.style.opacity = intensity;
      setTimeout(() => { flashOverlay.style.opacity = 0; }, 50);
    }
    
    function screenShake() {
      mainOverlay.classList.add('shake');
      setTimeout(() => mainOverlay.classList.remove('shake'), 300);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COLOR PALETTES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const palettes = [
      ['#FFD700', '#FFA500', '#FF8C00', '#FFEA00'],           // Gold
      ['#FF1744', '#FF5252', '#FF4081', '#F50057'],           // Red/Pink
      ['#00E5FF', '#18FFFF', '#00B8D4', '#84FFFF'],           // Cyan
      ['#00E676', '#69F0AE', '#00C853', '#B9F6CA'],           // Green
      ['#AA00FF', '#E040FB', '#D500F9', '#EA80FC'],           // Purple
      ['#FFFFFF', '#E0E0E0', '#F5F5F5', '#BDBDBD'],           // White/Silver
      ['#FF6D00', '#FF9100', '#FFAB00', '#FFD600'],           // Orange
      ['#2979FF', '#448AFF', '#2962FF', '#82B1FF'],           // Blue
      ['#F50057', '#FF4081', '#FF80AB', '#FF1744'],           // Pink
      ['#76FF03', '#B2FF59', '#CCFF90', '#64DD17'],           // Lime
    ];
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STARS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const stars = [];
    
    function createStars() {
      stars.length = 0;
      const count = Math.min(Math.floor((W * H) / 4000), 200); // Limit stars
      for (let i = 0; i < count; i++) {
        stars.push({
          x: Math.random() * W,
          y: Math.random() * H * 0.75,
          r: Math.random() * 1.5 + 0.5,
          twinkle: Math.random() * Math.PI * 2
        });
      }
    }
    createStars();
    window.addEventListener('resize', createStars);
    
    function drawStars(time) {
      ctx.fillStyle = '#ffffff';
      for (let i = 0; i < stars.length; i++) {
        const s = stars[i];
        const alpha = 0.5 + Math.sin(time * 0.002 + s.twinkle) * 0.3;
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PARTICLES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const particles = [];
    
    // Pre-parse color cache to avoid repeated hex parsing
    const colorCache = new Map();
    
    function getRGB(hex) {
      if (colorCache.has(hex)) return colorCache.get(hex);
      const rgb = {
        r: parseInt(hex.slice(1, 3), 16),
        g: parseInt(hex.slice(3, 5), 16),
        b: parseInt(hex.slice(5, 7), 16)
      };
      colorCache.set(hex, rgb);
      return rgb;
    }
    
    function createParticle(x, y, angle, speed, color, size, gravity, drag, life) {
      // Enforce particle limit - skip if at max
      if (particles.length >= MAX_PARTICLES) return;
      
      particles.push({
        x: x,
        y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        color: color,
        rgb: getRGB(color),
        size: size,
        gravity: gravity,
        drag: drag,
        life: life,
        maxLife: life,
        trailIdx: 0,
        trailX: new Float32Array(TRAIL_LENGTH),
        trailY: new Float32Array(TRAIL_LENGTH)
      });
    }
    
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        
        // Store trail using ring buffer (no array allocation)
        p.trailX[p.trailIdx] = p.x;
        p.trailY[p.trailIdx] = p.y;
        p.trailIdx = (p.trailIdx + 1) % TRAIL_LENGTH;
        
        // Physics
        p.vy += p.gravity;
        p.vx *= p.drag;
        p.vy *= p.drag;
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 1;
        
        // Remove dead particles or off-screen particles
        if (p.life <= 0 || p.y > H + 50) {
          particles.splice(i, 1);
        }
      }
    }
    
    function drawParticles() {
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        const alpha = p.life / p.maxLife;
        const size = p.size * alpha;
        const rgb = p.rgb;
        
        // Skip very faded particles
        if (alpha < 0.05) continue;
        
        // Draw trail (simplified - no gradient per trail point)
        ctx.fillStyle = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + (alpha * 0.3) + ')';
        for (let j = 0; j < TRAIL_LENGTH; j++) {
          const idx = (p.trailIdx + j) % TRAIL_LENGTH;
          const tx = p.trailX[idx];
          const ty = p.trailY[idx];
          if (tx === 0 && ty === 0) continue;
          const trailSize = size * (j / TRAIL_LENGTH) * 0.5;
          ctx.beginPath();
          ctx.arc(tx, ty, trailSize, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw glow (simplified - single color, no gradient)
        ctx.globalAlpha = alpha * 0.4;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, size * 2.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw core
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ROCKETS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const rockets = [];
    
    function launchRocket(specialType) {
      if (rockets.length >= MAX_ROCKETS) return;
      
      const x = W * 0.15 + Math.random() * W * 0.7;
      const type = specialType !== undefined ? specialType : Math.floor(Math.random() * 10);
      rockets.push({
        x: x,
        y: H + 20,
        vx: (Math.random() - 0.5) * 2,
        vy: -(10 + Math.random() * 5),
        targetY: H * 0.15 + Math.random() * H * 0.35,
        palette: palettes[Math.floor(Math.random() * palettes.length)],
        trailIdx: 0,
        trailX: new Float32Array(12),
        trailY: new Float32Array(12),
        trailLife: new Float32Array(12),
        type: type
      });
      playLaunch();
    }
    
    function updateRockets() {
      for (let i = rockets.length - 1; i >= 0; i--) {
        const r = rockets[i];
        
        // Store trail using ring buffer
        r.trailX[r.trailIdx] = r.x;
        r.trailY[r.trailIdx] = r.y;
        r.trailLife[r.trailIdx] = 1;
        r.trailIdx = (r.trailIdx + 1) % 12;
        
        // Decay trail
        for (let j = 0; j < 12; j++) {
          r.trailLife[j] -= 0.08;
        }
        
        // Physics
        r.vy += 0.12;
        r.x += r.vx;
        r.y += r.vy;
        
        // Check for explosion
        if (r.y <= r.targetY || r.vy >= -1) {
          explode(r);
          rockets.splice(i, 1);
        }
      }
    }
    
    function drawRockets() {
      for (let i = 0; i < rockets.length; i++) {
        const r = rockets[i];
        
        // Draw trail (simplified)
        for (let j = 0; j < 12; j++) {
          const life = r.trailLife[j];
          if (life <= 0) continue;
          const tx = r.trailX[j];
          const ty = r.trailY[j];
          const alpha = life * 0.6;
          const size = 3 + (j / 12) * 3;
          
          ctx.globalAlpha = alpha;
          ctx.fillStyle = '#ffcc66';
          ctx.beginPath();
          ctx.arc(tx, ty, size, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
        
        // Draw rocket head (simplified - no gradient)
        ctx.fillStyle = '#ffdd00';
        ctx.beginPath();
        ctx.arc(r.x, r.y, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(r.x, r.y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EXPLOSIONS - NOW WITH SPECIAL SHAPES!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function explode(rocket) {
      const x = rocket.x;
      const y = rocket.y;
      const palette = rocket.palette;
      const type = rocket.type;
      
      // Visual effects
      const isBigBoom = type >= 6;
      screenFlash(isBigBoom ? 0.4 : 0.2);
      if (isBigBoom) screenShake();
      playBoom(isBigBoom);
      
      // Flash particles
      for (let i = 0; i < 5; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 2;
        createParticle(x, y, angle, speed, '#FFFFFF', 6, 0, 0.95, 12);
      }
      
      const count = 80 + Math.floor(Math.random() * 40);
      
      switch(type) {
        case 0: // Spherical
          for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2 + (Math.random() - 0.5) * 0.2;
            const speed = 3 + Math.random() * 3.5;
            const color = palette[Math.floor(Math.random() * palette.length)];
            createParticle(x, y, angle, speed, color, 2.5 + Math.random(), 0.08, 0.985, 60 + Math.random() * 30);
          }
          break;
          
        case 1: // Chrysanthemum
          for (let layer = 0; layer < 3; layer++) {
            const layerCount = Math.floor(count / 3);
            const speed = 2 + layer * 1.5;
            for (let i = 0; i < layerCount; i++) {
              const angle = (i / layerCount) * Math.PI * 2;
              const color = layer % 2 === 0 ? palette[0] : '#FFFFFF';
              createParticle(x, y, angle, speed + Math.random(), color, 2 + Math.random(), 0.06, 0.988, 70 + Math.random() * 25);
            }
          }
          break;
          
        case 2: // Ring
          for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const speed = 4.5 + Math.random();
            const color = palette[i % palette.length];
            const vx = Math.cos(angle) * speed;
            const vy = Math.sin(angle) * speed * 0.3;
            if (particles.length < MAX_PARTICLES) {
              const rgb = getRGB(color);
              particles.push({
                x: x, y: y, vx: vx, vy: vy,
                color: color, rgb: rgb, size: 2.5, gravity: 0.05, drag: 0.985,
                life: 55, maxLife: 55, trailIdx: 0,
                trailX: new Float32Array(TRAIL_LENGTH),
                trailY: new Float32Array(TRAIL_LENGTH)
              });
            }
          }
          for (let i = 0; i < 20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 2.5;
            createParticle(x, y, angle, speed, '#FFFFFF', 1.5, 0.03, 0.98, 40);
          }
          break;
          
        case 3: // Willow
          for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const speed = 2 + Math.random() * 2;
            createParticle(x, y, angle, speed, palette[0], 2, 0.12, 0.992, 90 + Math.random() * 30);
          }
          break;
          
        case 4: // Double burst
          for (let i = 0; i < count / 2; i++) {
            const angle = (i / (count / 2)) * Math.PI * 2;
            createParticle(x, y, angle, 3 + Math.random(), palette[0], 2.5, 0.07, 0.985, 60);
          }
          for (let i = 0; i < count / 2; i++) {
            const angle = (i / (count / 2)) * Math.PI * 2 + 0.1;
            createParticle(x, y, angle, 5 + Math.random(), palette[2] || palette[1], 2.5, 0.07, 0.985, 60);
          }
          break;
          
        case 5: // Crossette
          const arms = 5;
          for (let arm = 0; arm < arms; arm++) {
            const baseAngle = (arm / arms) * Math.PI * 2;
            for (let i = 0; i < count / arms; i++) {
              const spread = (Math.random() - 0.5) * 0.4;
              const angle = baseAngle + spread;
              const speed = 2 + (i / (count / arms)) * 4.5;
              const color = palette[arm % palette.length];
              createParticle(x, y, angle, speed, color, 2 + Math.random(), 0.07, 0.985, 60 + Math.random() * 15);
            }
          }
          break;
          
        case 6: // â¤ï¸ HEART SHAPE
          const heartPoints = 60;
          for (let i = 0; i < heartPoints; i++) {
            const t = (i / heartPoints) * Math.PI * 2;
            const hx = 16 * Math.pow(Math.sin(t), 3);
            const hy = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
            const angle = Math.atan2(hy, hx);
            const dist = Math.sqrt(hx*hx + hy*hy);
            const speed = dist * 0.25 + Math.random() * 0.5;
            createParticle(x, y, angle, speed, '#FF1744', 3, 0.06, 0.988, 80 + Math.random() * 20);
          }
          // Fill with pink
          for (let i = 0; i < 30; i++) {
            const t = Math.random() * Math.PI * 2;
            const scale = Math.random() * 0.7;
            const hx = 16 * Math.pow(Math.sin(t), 3) * scale;
            const hy = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * scale;
            const angle = Math.atan2(hy, hx);
            const dist = Math.sqrt(hx*hx + hy*hy);
            createParticle(x, y, angle, dist * 0.2, '#FF80AB', 2, 0.05, 0.99, 70);
          }
          break;
          
        case 7: // â­ STAR SHAPE
          const starPoints = 5;
          const outerR = 5;
          const innerR = 2;
          for (let i = 0; i < 50; i++) {
            const idx = i % (starPoints * 2);
            const angle = (idx / (starPoints * 2)) * Math.PI * 2 - Math.PI / 2;
            const r = idx % 2 === 0 ? outerR : innerR;
            const speed = r + Math.random() * 1.5;
            createParticle(x, y, angle, speed, palette[0], 3, 0.06, 0.985, 70 + Math.random() * 20);
          }
          // Star trails
          for (let i = 0; i < starPoints; i++) {
            const angle = (i / starPoints) * Math.PI * 2 - Math.PI / 2;
            for (let j = 0; j < 8; j++) {
              const speed = 1 + j * 0.7;
              createParticle(x, y, angle, speed, '#FFFFFF', 2, 0.04, 0.99, 80);
            }
          }
          break;
          
        case 8: // ğŸŒ€ SPIRAL
          const spiralArms = 3;
          const spiralPoints = 40;
          for (let arm = 0; arm < spiralArms; arm++) {
            const armOffset = (arm / spiralArms) * Math.PI * 2;
            for (let i = 0; i < spiralPoints; i++) {
              const t = i / spiralPoints;
              const angle = armOffset + t * Math.PI * 4;
              const speed = 1 + t * 5;
              const color = palette[arm % palette.length];
              createParticle(x, y, angle, speed, color, 2.5, 0.05, 0.988, 70 + Math.random() * 20);
            }
          }
          break;
          
        case 9: // ğŸ’¥ MEGA CRACKLE (with delayed secondary explosions)
          for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2 + (Math.random() - 0.5) * 0.3;
            const speed = 3 + Math.random() * 3;
            const color = palette[Math.floor(Math.random() * palette.length)];
            createParticle(x, y, angle, speed, color, 2.5, 0.07, 0.985, 50 + Math.random() * 20);
          }
          // Schedule crackle effects
          for (let i = 0; i < 8; i++) {
            setTimeout(() => {
              const cx = x + (Math.random() - 0.5) * 150;
              const cy = y + (Math.random() - 0.5) * 150;
              for (let j = 0; j < 10; j++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                createParticle(cx, cy, angle, speed, '#FFFFFF', 1.5, 0.1, 0.97, 25);
              }
              playCrackle();
              screenFlash(0.1);
            }, 200 + i * 100 + Math.random() * 100);
          }
          break;
      }
      
      // Extra sparkles
      for (let i = 0; i < 15; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 1.5;
        createParticle(x, y, angle, speed, '#FFFFFF', 1, 0.02, 0.98, 30 + Math.random() * 15);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONFETTI
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const confetti = [];
    const confettiColors = ['#ff0080', '#ffef00', '#00ff88', '#00cfff', '#ff8c00', '#a855f7'];
    
    function spawnConfetti() {
      if (confetti.length < MAX_CONFETTI && Math.random() < 0.3) {
        confetti.push({
          x: Math.random() * W,
          y: -10,
          vx: (Math.random() - 0.5) * 2,
          vy: 2 + Math.random() * 2,
          size: 6 + Math.random() * 6,
          color: confettiColors[Math.floor(Math.random() * confettiColors.length)],
          rotation: Math.random() * 360,
          rotationSpeed: (Math.random() - 0.5) * 8,
          wobble: Math.random() * Math.PI * 2,
          wobbleSpeed: 0.05 + Math.random() * 0.05
        });
      }
    }
    
    function updateConfetti() {
      for (let i = confetti.length - 1; i >= 0; i--) {
        const c = confetti[i];
        c.wobble += c.wobbleSpeed;
        c.x += c.vx + Math.sin(c.wobble) * 1.5;
        c.y += c.vy;
        c.rotation += c.rotationSpeed;
        
        if (c.y > H + 20) {
          confetti.splice(i, 1);
        }
      }
    }
    
    function drawConfetti() {
      for (let i = 0; i < confetti.length; i++) {
        const c = confetti[i];
        ctx.save();
        ctx.translate(c.x, c.y);
        ctx.rotate(c.rotation * Math.PI / 180);
        ctx.fillStyle = c.color;
        ctx.fillRect(-c.size / 2, -c.size / 4, c.size, c.size / 2);
        ctx.restore();
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MAIN LOOP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let lastLaunch = 0;
    let launchInterval = 300;
    
    function animate(time) {
      // Cache sky gradient
      if (!skyGradientCache) {
        skyGradientCache = ctx.createLinearGradient(0, 0, 0, H);
        skyGradientCache.addColorStop(0, '#0a0a18');
        skyGradientCache.addColorStop(0.5, '#101028');
        skyGradientCache.addColorStop(1, '#1a1a38');
      }
      ctx.fillStyle = skyGradientCache;
      ctx.fillRect(0, 0, W, H);
      
      drawStars(time);
      
      // Finale mode - rapid fire!
      if (finaleMode && time < finaleEndTime) {
        if (time - lastLaunch > 80) {
          launchRocket(Math.floor(Math.random() * 10));
          if (Math.random() < 0.3) launchRocket(6 + Math.floor(Math.random() * 4)); // Special shapes
          lastLaunch = time;
        }
      } else {
        if (finaleMode) finaleMode = false;
        if (time - lastLaunch > launchInterval) {
          launchRocket();
          lastLaunch = time;
          launchInterval = 250 + Math.random() * 500;
        }
      }
      
      updateRockets();
      updateParticles();
      spawnConfetti();
      updateConfetti();
      
      drawConfetti();
      drawRockets();
      drawParticles();
      
      requestAnimationFrame(animate);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GRAND FINALE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function triggerFinale() {
      if (finaleMode) return;
      initAudio();
      finaleMode = true;
      finaleEndTime = performance.now() + 10000; // 10 seconds
      finaleText.classList.add('show');
      setTimeout(() => finaleText.classList.remove('show'), 3000);
      
      // Launch initial burst
      for (let i = 0; i < 5; i++) {
        setTimeout(() => launchRocket(6 + Math.floor(Math.random() * 4)), i * 50);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // KEYBOARD CONTROLS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    document.addEventListener('keydown', function(e) {
      if (e.key === 'f' || e.key === 'F') {
        triggerFinale();
      }
      if (e.key === 's' || e.key === 'S') {
        initAudio();
        soundEnabled = !soundEnabled;
        console.log('%cğŸ”Š Sound: ' + (soundEnabled ? 'ON' : 'OFF'), 'font-size:14px; color:#00E5FF;');
      }
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CLICK TO LAUNCH EXTRA FIREWORKS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    document.addEventListener('click', function(e) {
      initAudio();
      for (let i = 0; i < 3; i++) {
        setTimeout(function() {
          if (rockets.length >= MAX_ROCKETS) return;
          const specialChance = Math.random();
          const type = specialChance < 0.3 ? (6 + Math.floor(Math.random() * 4)) : Math.floor(Math.random() * 6);
          const r = {
            x: e.clientX + (Math.random() - 0.5) * 80,
            y: H + 20,
            vx: (Math.random() - 0.5) * 3,
            vy: -(12 + Math.random() * 4),
            targetY: e.clientY * 0.8,
            palette: palettes[Math.floor(Math.random() * palettes.length)],
            trailIdx: 0,
            trailX: new Float32Array(12),
            trailY: new Float32Array(12),
            trailLife: new Float32Array(12),
            type: type
          };
          rockets.push(r);
          playLaunch();
        }, i * 100);
      }
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // START THE SHOW!!!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    for (let i = 0; i < 8; i++) {
      setTimeout(launchRocket, i * 120);
    }
    
    requestAnimationFrame(animate);
    
    console.log('%cğŸ† Happy New Year 2025! ğŸ†', 'font-size:24px; color:#FFD700; text-shadow:0 0 10px #FF6600;');
    console.log('%câœ¨ SO AWESOME!!! âœ¨', 'font-size:18px; color:#FF0080;');
    console.log('%cControls: [F] Grand Finale | [S] Toggle Sound | [Click] Launch', 'font-size:14px; color:#00E5FF;');
    
  })();
  </script>
</body>
</html>