"""
xml2md - Convert JUnit XML test reports to beautiful Markdown reports.

This utility parses JUnit XML format test reports (generated by pytest)
and creates nicely formatted Markdown reports with summary statistics
and detailed test results.

Usage:
    uv run xml2md report.xml                    # Output to report.md
    uv run xml2md report.xml -o custom.md       # Custom output path
    uv run xml2md report.xml --output results/  # Output to directory
"""

import xml.etree.ElementTree as ET
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path

import click


@dataclass
class TestCase:
    """Represents a single test case result."""
    classname: str
    name: str
    time: float
    status: str  # "passed", "failed", "skipped", "error"
    message: str | None = None
    details: str | None = None


@dataclass
class TestSuite:
    """Represents a test suite with multiple test cases."""
    name: str
    tests: int
    errors: int
    failures: int
    skipped: int
    time: float
    timestamp: str
    hostname: str
    test_cases: list[TestCase]

    @property
    def passed(self) -> int:
        """Calculate number of passed tests."""
        return self.tests - self.errors - self.failures - self.skipped


def parse_junit_xml(xml_path: Path) -> list[TestSuite]:
    """
    Parse a JUnit XML report file.

    Args:
        xml_path: Path to the JUnit XML file

    Returns:
        List of TestSuite objects
    """
    tree = ET.parse(xml_path)
    root = tree.getroot()

    suites = []

    # Handle both <testsuites> wrapper and direct <testsuite>
    if root.tag == "testsuites":
        suite_elements = root.findall("testsuite")
    else:
        suite_elements = [root]

    for suite_elem in suite_elements:
        test_cases = []

        for case_elem in suite_elem.findall("testcase"):
            # Determine test status
            status = "passed"
            message = None
            details = None

            failure = case_elem.find("failure")
            error = case_elem.find("error")
            skipped = case_elem.find("skipped")

            if failure is not None:
                status = "failed"
                message = failure.get("message", "")
                details = failure.text
            elif error is not None:
                status = "error"
                message = error.get("message", "")
                details = error.text
            elif skipped is not None:
                status = "skipped"
                message = skipped.get("message", "")

            test_case = TestCase(
                classname=case_elem.get("classname", ""),
                name=case_elem.get("name", ""),
                time=float(case_elem.get("time", 0)),
                status=status,
                message=message,
                details=details,
            )
            test_cases.append(test_case)

        suite = TestSuite(
            name=suite_elem.get("name", "pytest"),
            tests=int(suite_elem.get("tests", 0)),
            errors=int(suite_elem.get("errors", 0)),
            failures=int(suite_elem.get("failures", 0)),
            skipped=int(suite_elem.get("skipped", 0)),
            time=float(suite_elem.get("time", 0)),
            timestamp=suite_elem.get("timestamp", ""),
            hostname=suite_elem.get("hostname", ""),
            test_cases=test_cases,
        )
        suites.append(suite)

    return suites


def format_duration(seconds: float) -> str:
    """Format duration in human-readable format."""
    if seconds < 1:
        return f"{seconds * 1000:.0f}ms"
    elif seconds < 60:
        return f"{seconds:.2f}s"
    else:
        minutes = int(seconds // 60)
        secs = seconds % 60
        return f"{minutes}m {secs:.1f}s"


def get_status_emoji(status: str) -> str:
    """Get emoji for test status."""
    return {
        "passed": "âœ…",
        "failed": "âŒ",
        "error": "ðŸ’¥",
        "skipped": "â­ï¸",
    }.get(status, "â“")


def generate_markdown(suites: list[TestSuite], xml_path: Path) -> str:
    """
    Generate a Markdown report from test suites.

    Args:
        suites: List of TestSuite objects
        xml_path: Original XML file path (for reference)

    Returns:
        Formatted Markdown string
    """
    lines = []

    # Header
    lines.append("# Test Report")
    lines.append("")

    # Metadata
    timestamp = suites[0].timestamp if suites else datetime.now().isoformat()
    try:
        # Parse and format timestamp
        dt = datetime.fromisoformat(timestamp.replace("Z", "+00:00"))
        formatted_time = dt.strftime("%B %d, %Y at %H:%M:%S %Z")
    except (ValueError, AttributeError):
        formatted_time = timestamp

    lines.append(f"**Generated:** {formatted_time}  ")
    lines.append(f"**Source:** `{xml_path.name}`  ")
    if suites and suites[0].hostname:
        lines.append(f"**Host:** `{suites[0].hostname}`  ")
    lines.append("")

    # Overall Summary
    total_tests = sum(s.tests for s in suites)
    total_passed = sum(s.passed for s in suites)
    total_failed = sum(s.failures for s in suites)
    total_errors = sum(s.errors for s in suites)
    total_skipped = sum(s.skipped for s in suites)
    total_time = sum(s.time for s in suites)

    lines.append("## Summary")
    lines.append("")

    # Status badge
    if total_failed == 0 and total_errors == 0:
        lines.append("ðŸŽ‰ **All tests passed!**")
    else:
        lines.append(
            f"âš ï¸ **{total_failed + total_errors} test(s) need attention**")
    lines.append("")

    # Summary table
    lines.append("| Metric | Count |")
    lines.append("|--------|-------|")
    lines.append(f"| âœ… Passed | {total_passed} |")
    lines.append(f"| âŒ Failed | {total_failed} |")
    lines.append(f"| ðŸ’¥ Errors | {total_errors} |")
    lines.append(f"| â­ï¸ Skipped | {total_skipped} |")
    lines.append(f"| **Total** | **{total_tests}** |")
    lines.append(f"| â±ï¸ Duration | {format_duration(total_time)} |")
    lines.append("")

    # Pass rate
    if total_tests > 0:
        pass_rate = (total_passed / total_tests) * 100
        lines.append(f"**Pass Rate:** {pass_rate:.1f}%")
        lines.append("")

    # Detailed Results
    lines.append("## Detailed Results")
    lines.append("")

    for suite in suites:
        if len(suites) > 1:
            lines.append(f"### {suite.name}")
            lines.append("")

        # Group tests by class
        tests_by_class: dict[str, list[TestCase]] = {}
        for tc in suite.test_cases:
            # Extract the class name without module path for cleaner display
            class_parts = tc.classname.split(".")
            class_name = class_parts[-1] if class_parts else tc.classname

            if class_name not in tests_by_class:
                tests_by_class[class_name] = []
            tests_by_class[class_name].append(tc)

        for class_name, tests in tests_by_class.items():
            lines.append(f"### {class_name}")
            lines.append("")
            lines.append("| Status | Test | Duration |")
            lines.append("|:------:|------|----------|")

            for tc in tests:
                emoji = get_status_emoji(tc.status)
                # Clean up test name (remove browser suffix like [chromium])
                test_name = tc.name
                if "[" in test_name:
                    test_name = test_name.split("[")[0]
                    browser = tc.name.split("[")[1].rstrip("]")
                    test_name = f"{test_name} `[{browser}]`"

                lines.append(
                    f"| {emoji} | {test_name} | {format_duration(tc.time)} |")

            lines.append("")

        # Failed tests details
        failed_tests = [
            tc for tc in suite.test_cases if tc.status in ("failed", "error")]
        if failed_tests:
            lines.append("## Failures & Errors")
            lines.append("")

            for tc in failed_tests:
                emoji = get_status_emoji(tc.status)
                lines.append(f"### {emoji} {tc.name}")
                lines.append("")
                lines.append(f"**Class:** `{tc.classname}`  ")
                lines.append(f"**Status:** {tc.status.upper()}  ")
                lines.append("")

                if tc.message:
                    lines.append("**Message:**")
                    lines.append("```")
                    lines.append(tc.message)
                    lines.append("```")
                    lines.append("")

                if tc.details:
                    lines.append("**Details:**")
                    lines.append("```")
                    lines.append(tc.details.strip())
                    lines.append("```")
                    lines.append("")

    # Footer
    lines.append("---")
    lines.append("")
    lines.append("*Generated by xml2md*")

    return "\n".join(lines)


@click.command()
@click.argument("xml_file", type=click.Path(exists=True, path_type=Path))
@click.option(
    "-o", "--output",
    type=click.Path(path_type=Path),
    help="Output path for Markdown file. Can be a file or directory.",
)
def main(xml_file: Path, output: Path | None) -> None:
    """
    Convert a JUnit XML test report to a Markdown report.

    XML_FILE is the path to the JUnit XML report to convert.

    Examples:

        xml2md report.xml                    # Output to report.md

        xml2md report.xml -o custom.md       # Custom output file

        xml2md report.xml -o results/        # Output to directory
    """
    # Parse the XML
    try:
        suites = parse_junit_xml(xml_file)
    except ET.ParseError as e:
        raise click.ClickException(f"Failed to parse XML: {e}")

    # Generate Markdown
    markdown = generate_markdown(suites, xml_file)

    # Determine output path
    if output is None:
        output_path = xml_file.with_suffix(".md")
    elif output.is_dir() or str(output).endswith("/"):
        output.mkdir(parents=True, exist_ok=True)
        output_path = output / xml_file.with_suffix(".md").name
    else:
        output_path = output
        output_path.parent.mkdir(parents=True, exist_ok=True)

    # Write output
    output_path.write_text(markdown)
    click.echo(f"âœ… Markdown report saved to: {output_path}")


if __name__ == "__main__":
    main()
